<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gerador de Cenas Bíblicas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-XXXXXXXXXXXXXXXX" crossorigin="anonymous"></script>
    
    <!-- Babel Standalone for JSX/TSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Import map for all modules -->
    <script type="importmap">
{
  "imports": {
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.29.0",
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
  }
}
</script>
</head>
  <body class="bg-slate-900 text-white">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
// Note: This HTML file contains the entire application.

import { GoogleGenAI, Modality, Type } from "@google/genai";
import React, { useState, useEffect, useCallback, StrictMode, useRef } from "react";
import ReactDOM from "react-dom/client";


// --- UTILS ---

const audioUtils = (() => {
    const writeString = (view, offset, string) => {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    };

    const createWavBlob = (base64) => {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const pcmData = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            pcmData[i] = binaryString.charCodeAt(i);
        }

        const sampleRate = 24000;
        const numChannels = 1;
        const bitsPerSample = 16;
        const dataSize = pcmData.length;

        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);

        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + dataSize, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * (bitsPerSample / 8), true);
        view.setUint16(32, numChannels * (bitsPerSample / 8), true);
        view.setUint16(34, bitsPerSample, true);
        writeString(view, 36, 'data');
        view.setUint32(40, dataSize, true);
        
        for (let i = 0; i < dataSize; i++) {
            view.setUint8(44 + i, pcmData[i]);
        }

        return new Blob([view], { type: 'audio/wav' });
    };
    return { createWavBlob };
})();

// --- SERVICES ---

const usageService = (() => {
    let cachedIdentifier = null;

    const getUserIdentifier = async () => {
        if (cachedIdentifier) {
            return cachedIdentifier;
        }
        try {
            const response = await fetch('https://api.ipify.org?format=json');
            if (!response.ok) {
                throw new Error(`Failed to fetch IP: ${response.statusText}`);
            }
            const data = await response.json();
            cachedIdentifier = data.ip;
            return data.ip;
        } catch (error) {
            console.error("Could not fetch IP, using fallback identifier:", error);
            const fallback = 'session_' + Date.now().toString(36);
            cachedIdentifier = fallback;
            return fallback;
        }
    };

    const getUsageCountKey = (id) => `bbSceneGenCount_${id}`;
    const getUnlockedKey = (id) => `bbSceneGenUnlocked_${id}`;

    const getUsageCount = (identifier) => {
        return parseInt(localStorage.getItem(getUsageCountKey(identifier)) || '0');
    };

    const isUnlocked = (identifier) => {
        return localStorage.getItem(getUnlockedKey(identifier)) === 'true';
    };

    const incrementUsageCount = (identifier) => {
        if (isUnlocked(identifier)) return;
        const currentCount = getUsageCount(identifier);
        localStorage.setItem(getUsageCountKey(identifier), (currentCount + 1).toString());
    };

    const unlockApp = (identifier) => {
        localStorage.setItem(getUnlockedKey(identifier), 'true');
    };

    return { getUserIdentifier, getUsageCount, isUnlocked, incrementUsageCount, unlockApp };
})();

const geminiService = (() => {
    // IMPORTANTE: process.env.API_KEY não funciona em um ambiente de servidor web estático como cPanel.
    // A chave de API precisa ser fornecida de outra forma (por exemplo, embutida aqui, o que não é seguro,
    // ou obtida de um endpoint de backend seguro).
    const API_KEY = process.env.API_KEY;
    if (!API_KEY) {
        console.error("API_KEY environment variable not set. This will not work on a standard web server.");
        const errorFn = () => Promise.reject(new Error("API_KEY is not configured."));
        return {
            generateImagePrompt: errorFn,
            generateImage: errorFn,
            getVerseText: errorFn,
            generateSpeech: errorFn,
            generatePresentationAudio: errorFn,
            generateVoicePreview: errorFn,
        };
    }

    const ai = new GoogleGenAI({ apiKey: API_KEY });

    const STYLE_PROMPT_APPENDIX = `, no estilo de um desenho da Pixar, personagens expressivos, iluminação cinematográfica, 3D, 4K, alto detalhe`;

    const generateImagePrompt = async (bibleReference, existingCharacters) => {
      try {
        const isContinuation = existingCharacters && Object.keys(existingCharacters).length > 0;
        const existingCharsAsArray = isContinuation
          ? Object.entries(existingCharacters).map(([name, description]) => ({ name, description }))
          : [];

        const characterInstructions = isContinuation
          ? `Você DEVE usar as seguintes descrições de personagens para consistência: ${JSON.stringify(existingCharsAsArray, null, 2)}. Não altere essas descrições.`
          : `Sua primeira tarefa é criar descrições detalhadas e reutilizáveis para cada personagem na cena. Seja específico sobre características faciais, cabelo, roupas, idade e físico para que possam ser recriados de forma idêntica.`;

        const prompt = `
Sua tarefa é analisar o versículo bíblico '${bibleReference}' e gerar um objeto JSON para criar uma cena visual.
Sua prioridade máxima é a precisão teológica, histórica e a consistência visual dos personagens em cenas sequenciais.

${characterInstructions}

Se o versículo bíblico solicitado não existir (por exemplo, o próximo versículo após o final de um capítulo), sua resposta JSON DEVE ser: { "error": "VERSE_NOT_FOUND" }. Não tente adivinhar ou criar conteúdo.

Baseado na sua análise e nas instruções de personagem, gere um objeto JSON com o seguinte formato:
{
  "scenePrompt": "Um parágrafo único, detalhado e vívido, descrevendo a nova cena, o ambiente, a iluminação e a ação principal. Este será usado para gerar a imagem.",
  "characterDescriptions": [
    {
      "name": "NomeDoPersonagem1",
      "description": "Descrição visual detalhada e reutilizável..."
    },
    {
      "name": "NomeDoPersonagem2",
      "description": "Descrição visual detalhada e reutilizável..."
    }
  ]
}

- **Regra Crítica: Fidelidade Bíblica na Aparência:** A aparência física DEVE ser sua prioridade máxima.
  - **Base Teológica:** Baseie-se estritamente em descrições bíblicas e no contexto histórico do antigo Oriente Médio.
  - **Inferência Lógica:** Vá além do texto literal. Você DEVE inferir características físicas a partir de detalhes narrativos. Por exemplo, a Bíblia descreve o sacerdote Eli como "velho e pesado" (1 Samuel 4:18). Portanto, sua descrição visual DEVE refleti-lo como um homem idoso, significativamente acima do peso e de baixa estatura para acentuar sua corpulência. Aplique essa mesma lógica de inferência para TODOS os personagens.
  - **Etnia:** Evite representações eurocêntricas. Todos os personagens devem ter traços consistentes com a etnia do Oriente Médio (pele morena, cabelo escuro, etc.), a menos que o texto especifique o contrário.
- **Regra de Segurança CRÍTICA (Prioridade Máxima):** O prompt gerado será usado por uma IA de imagem com filtros de segurança MUITO rigorosos. A falha em seguir estas regras resultará em um erro de geração. Sua tarefa é criar um prompt que SEJA SEGURO.
  - **PROIBIDO Conteúdo Violento:** NÃO descreva sangue, ferimentos, armas em uso, combate, morte explícita ou qualquer forma de violência gráfica. Esta é a principal causa de falha.
  - **FOCO NO EMOCIONAL E IMPLÍCITO:** Em vez de descrever a ação violenta, foque 100% nas emoções dos personagens, nas reações e no resultado da ação.
    - **Exemplo RUIM (Resulta em erro):** "Davi atirou a pedra que atingiu a testa de Golias, que caiu morto."
    - **Exemplo BOM (Funciona):** "Davi observa com determinação enquanto o gigante Golias, com uma expressão de surpresa, cambaleia e cai no chão, derrotado. A tensão no campo de batalha se transforma em espanto."
    - **Exemplo RUIM (Resulta em erro):** "Eli caiu e quebrou o pescoço."
    - **Exemplo BOM (Funciona):** "O sacerdote Eli, ao ouvir a notícia trágica, cai para trás de sua cadeira em choque, seu corpo imóvel no chão, enquanto as pessoas ao redor reagem com desespero."
  - **PROIBIDO Conteúdo Adulto:** NÃO descreva nudez ou roupas reveladoras. Os personagens devem usar vestimentas modestas e historicamente apropriadas.
  - **Palavras-Chave a Evitar:** Evite estritamente palavras como "matar", "sangue", "ferida", "morte", "luta", "batalha", "arma", "nudez". Descreva a cena de forma a contornar essas palavras.
- **JSON de Saída:** Sua resposta final deve ser APENAS o objeto JSON, sem nenhum texto ou formatação adicional. Se você está continuando uma cena, a lista 'characterDescriptions' retornada deve ser a mesma que foi fornecida, a menos que um novo personagem seja introduzido.
`;

        const response = await ai.models.generateContent({
          model: 'gemini-2.5-flash',
          contents: prompt,
          config: {
            responseMimeType: 'application/json',
            responseSchema: {
              type: Type.OBJECT,
              properties: {
                error: { type: Type.STRING, description: 'Campo de erro opcional.', nullable: true },
                scenePrompt: { type: Type.STRING, description: 'O prompt detalhado para gerar a imagem.' },
                characterDescriptions: {
                  type: Type.ARRAY,
                  description: 'Uma lista de objetos, cada um contendo o nome e a descrição de um personagem.',
                  items: {
                      type: Type.OBJECT,
                      properties: {
                          name: { type: Type.STRING, description: 'O nome do personagem.'},
                          description: { type: Type.STRING, description: 'A descrição visual do personagem.'}
                      },
                      required: ['name', 'description']
                  }
                },
              },
            },
          },
        });

        const rawText = response.text.trim();
        const extractJsonString = (str) => {
            const match = str.match(/\{[\s\S]*\}/);
            return match ? match[0] : str;
        };
        const jsonString = extractJsonString(rawText);

        try {
            const parsedJson = JSON.parse(jsonString);
            if (parsedJson.error === 'VERSE_NOT_FOUND') throw new Error('VERSE_NOT_FOUND');
            if (!parsedJson.scenePrompt || !parsedJson.characterDescriptions) throw new Error("Resposta da IA com campos ausentes.");

            const characterDescriptionsMap = parsedJson.characterDescriptions.reduce((acc, char) => {
                acc[char.name] = char.description;
                return acc;
            }, {});

            return {
                scenePrompt: parsedJson.scenePrompt,
                characterDescriptions: characterDescriptionsMap,
            };
        } catch (e) {
            if (e.message === 'VERSE_NOT_FOUND') throw e; 
            console.error("Failed to parse JSON response from AI:", rawText);
            throw new Error("Falha ao processar a resposta da IA. O formato pode ser inválido.");
        }
      } catch (error) {
        console.error("Error generating image prompt:", error);
        throw error;
      }
    };

    const generateImage = async (prompt, aspectRatio) => {
      try {
        const fullPrompt = prompt + STYLE_PROMPT_APPENDIX;
        const response = await ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: fullPrompt,
            config: {
              numberOfImages: 1,
              outputMimeType: 'image/jpeg',
              aspectRatio: aspectRatio,
            },
        });

        if (response.generatedImages && response.generatedImages.length > 0) {
          return response.generatedImages[0].image.imageBytes;
        } else {
          throw new Error("A imagem não pôde ser gerada. Isso pode ocorrer devido a filtros de segurança sobre o conteúdo da cena. Tente um versículo diferente ou uma nova cena com uma descrição menos explícita.");
        }
      } catch (error) {
        console.error("Error generating image:", error);
        throw error;
      }
    };

    const languageMap = {
        'pt-BR': 'Português (Brasil)',
        'en-US': 'Inglês (EUA)',
        'es-ES': 'Espanhol (Espanha)',
        'fr-FR': 'Francês (França)',
        'de-DE': 'Alemão (Alemanha)',
    };

    const getVerseText = async (bibleReference, language) => {
      try {
        const languageName = languageMap[language] || 'Português (Brasil)';
        const textPrompt = `Forneça o texto completo de '${bibleReference}' da Bíblia no idioma ${languageName}. Responda apenas com o texto do versículo, sem introduções ou explicações adicionais.`;
        const textResponse = await ai.models.generateContent({
          model: 'gemini-2.5-flash',
          contents: textPrompt,
        });
        const bibleText = textResponse.text.trim();
        if (!bibleText) throw new Error("Não foi possível obter o texto do versículo.");
        return bibleText;
      } catch (error) {
        console.error("Error fetching verse text:", error);
        throw error;
      }
    };

    const generateSpeech = async (textToNarrate, voiceType) => {
      try {
        if (!textToNarrate) throw new Error("O texto para narração não pode estar vazio.");
        const voiceName = voiceType === 'adulta' ? 'Puck' : 'Kore';
        let promptForAudio = voiceType === 'infantil' ? `Narração em tom de criança, com uma voz doce e clara: ${textToNarrate}` : textToNarrate;
        
        const audioResponse = await ai.models.generateContent({
          model: "gemini-2.5-flash-preview-tts",
          contents: [{ parts: [{ text: promptForAudio }] }],
          config: {
            responseModalities: [Modality.AUDIO],
            speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName } } },
          },
        });

        const base64Audio = audioResponse.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
        if (base64Audio) return base64Audio;
        throw new Error("A API não retornou nenhum áudio.");
      } catch (error) {
        console.error("Error generating speech:", error);
        throw error;
      }
    };
    
    const generatePresentationAudio = async () => {
        try {
            const presentationText = `Olá! Bem-vindo ao Gerador de Cenas Bíblicas. Uma ferramenta revolucionária que transforma as escrituras sagradas em arte visual deslumbrante no estilo Pixar. Crie cenas, siga personagens e até mesmo ouça narrações. Dê vida à sua fé. Comece agora!`;
            const audioResponse = await ai.models.generateContent({
              model: "gemini-2.5-flash-preview-tts",
              contents: [{ parts: [{ text: presentationText }] }],
              config: {
                responseModalities: [Modality.AUDIO],
                speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: 'Puck' } } },
              },
            });
            const base64Audio = audioResponse.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
            if (base64Audio) return base64Audio;
            throw new Error("A API não retornou nenhum áudio para a apresentação.");
          } catch (error) {
            console.error("Error generating presentation speech:", error);
            throw error;
          }
    };
    
    const generateVoicePreview = async (voiceType) => {
        try {
            const voiceName = voiceType === 'adulta' ? 'Puck' : 'Kore';
            const previewText = voiceType === 'adulta'
                ? "Olá, esta é uma prévia da minha voz. Eu posso narrar as escrituras para você."
                : "Oi! Essa é a minha vozinha. Eu posso contar as histórias da Bíblia para as crianças!";

            const audioResponse = await ai.models.generateContent({
                model: "gemini-2.5-flash-preview-tts",
                contents: [{ parts: [{ text: previewText }] }],
                config: {
                    responseModalities: [Modality.AUDIO],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName } } },
                },
            });
            const base64Audio = audioResponse.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
            if (base64Audio) return base64Audio;
            throw new Error("A API não retornou áudio para a prévia.");
        } catch (error) {
            console.error("Error generating voice preview:", error);
            throw error;
        }
    };

    return { generateImagePrompt, generateImage, getVerseText, generateSpeech, generatePresentationAudio, generateVoicePreview };
})();

// --- ICONS ---

const DownloadIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props} >
    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
    <polyline points="7 10 12 15 17 10" />
    <line x1="12" y1="15" x2="12" y2="3" />
  </svg>
);
const MicIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props} >
    <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
    <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
    <line x1="12" x2="12" y1="19" y2="22"/>
  </svg>
);
const SparklesIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props} >
    <path d="m12 3-1.9 5.8-5.8 1.9 5.8 1.9 1.9 5.8 1.9-5.8 5.8-1.9-5.8-1.9Z"/>
    <path d="M5 3v4"/> <path d="M19 17v4"/> <path d="M3 5h4"/> <path d="M17 19h4"/>
  </svg>
);
const SpeakerIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props} >
    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
    <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
  </svg>
);
const UsersIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props} >
    <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/> <circle cx="9" cy="7" r="4"/>
    <path d="M22 21v-2a4 4 0 0 0-3-3.87"/> <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
  </svg>
);
const PlayIcon = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="0" strokeLinecap="round" strokeLinejoin="round" {...props}>
    <path d="M8 5v14l11-7z" />
  </svg>
);

// --- COMPONENTS ---

const Spinner = () => {
  return <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>;
};

const AdSenseUnit = () => {
    const AD_CLIENT = 'ca-pub-XXXXXXXXXXXXXXXX';
    const AD_SLOT = 'YYYYYYYYYY';
    const adPushed = useRef(false);

    useEffect(() => {
        // This check prevents the ad from being pushed multiple times due to
        // React.StrictMode's re-rendering behavior in development.
        if (adPushed.current) {
            return;
        }

        const timeoutId = setTimeout(() => {
            try {
                (window.adsbygoogle = window.adsbygoogle || []).push({});
                adPushed.current = true; // Mark as pushed to avoid re-pushing.
            } catch (err) {
                console.error('AdSense error:', err);
            }
        }, 100); // Delaying the push helps ensure the ad container has a calculated size.

        return () => clearTimeout(timeoutId);
    }, []);

    return (
        <div className="my-6 text-center bg-slate-800/50 p-4 rounded-lg flex items-center justify-center min-h-[100px]">
            <ins
                className="adsbygoogle"
                style={{ display: 'block', width: '100%' }}
                data-ad-client={AD_CLIENT}
                data-ad-slot={AD_SLOT}
                data-ad-format="auto"
                data-full-width-responsive="true"
            ></ins>
        </div>
    );
};

const PaywallPopup = ({ onUnlock }) => {
    const [code, setCode] = useState('');
    const [error, setError] = useState('');

    const handleUnlock = () => {
        if (code.trim() === '#jesusecaminhoaverdadeeavida#') {
            onUnlock();
        } else {
            setError('Código de acesso inválido. Por favor, verifique e tente novamente.');
        }
    };

    return (
        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4" aria-modal="true" role="dialog">
            <div className="bg-slate-800 border border-cyan-500/50 rounded-2xl shadow-2xl shadow-cyan-500/20 max-w-lg w-full p-8 text-center animate-fade-in-up">
                <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500 mb-4">
                    Acesso Gratuito Esgotado
                </h2>
                <p className="text-gray-300 mb-6">
                    Você utilizou suas 3 gerações de imagem gratuitas. Para continuar criando cenas incríveis, adquira seu acesso vitalício.
                </p>
                <a href="https://portifoliosocialmedia.com.br" target="_blank" rel="noopener noreferrer" className="block w-full bg-gradient-to-r from-cyan-500 to-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:from-cyan-600 hover:to-blue-700 transition duration-300 transform hover:scale-105 mb-6">
                    Compre a Ferramenta por R$7,00 (Acesso Vitalício)
                </a>
                <p className="text-gray-400 mb-4 text-sm">
                    Após a compra, você receberá um código de acesso. Insira-o abaixo para desbloquear o gerador.
                </p>
                <div className="flex flex-col gap-2">
                     <input type="text" value={code} onChange={(e) => { setCode(e.target.value); setError(''); }} placeholder="Insira seu código de acesso aqui"
                        className="w-full bg-slate-900 border border-slate-600 rounded-lg px-4 py-3 text-gray-200 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition duration-300"
                    />
                    <button onClick={handleUnlock} className="w-full bg-slate-600 text-white font-bold py-3 px-5 rounded-lg hover:bg-slate-700 transition duration-300">
                        Desbloquear
                    </button>
                </div>
                {error && <p className="mt-4 text-red-400 text-sm">{error}</p>}
            </div>
             <style>{`
                @keyframes fade-in-up {
                    from { opacity: 0; transform: translateY(20px); }
                    to { opacity: 1; transform: translateY(0); }
                }
                .animate-fade-in-up {
                    animation: fade-in-up 0.3s ease-out forwards;
                }
            `}</style>
        </div>
    );
};

const Header = ({ onLogout }) => {
  return (
    <header className="bg-slate-900/50 backdrop-blur-sm shadow-lg shadow-cyan-500/10 border-b border-slate-700 relative">
      <div className="container mx-auto px-4 py-5 text-center">
        <h1 className="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
          Gerador de Cenas Bíblicas
        </h1>
        <p className="text-gray-400 mt-2 text-sm md:text-base">
          Transforme capítulos da Bíblia em arte no estilo Pixar
        </p>
      </div>
      <button onClick={onLogout} className="absolute top-1/2 right-4 -translate-y-1/2 bg-slate-700 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors duration-300 text-sm">
        Sair
      </button>
    </header>
  );
};

const ImageGenerator = () => {
  const [bibleReference, setBibleReference] = useState('');
  const [promptText, setPromptText] = useState('');
  const [characterDescriptions, setCharacterDescriptions] = useState(null);
  const [isSequenceActive, setIsSequenceActive] = useState(false);
  const [isPromptLoading, setIsPromptLoading] = useState(false);
  const [promptError, setPromptError] = useState(null);
  const [isImageLoading, setIsImageLoading] = useState(false);
  const [generatedImage, setGeneratedImage] = useState(null);
  const [imageError, setImageError] = useState(null);
  const [aspectRatio, setAspectRatio] = useState('9:16');
  const [language, setLanguage] = useState('pt-BR');
  const [voiceType, setVoiceType] = useState('masculina');
  const [isAudioLoading, setIsAudioLoading] = useState(false);
  const [audioError, setAudioError] = useState(null);
  const [generatedAudioUrl, setGeneratedAudioUrl] = useState(null);
  const [narratedText, setNarratedText] = useState(null);
  const [textForNarration, setTextForNarration] = useState('');
  const [isFetchingVerse, setIsFetchingVerse] = useState(false);
  const [showPaywall, setShowPaywall] = useState(false);
  const [previewLoading, setPreviewLoading] = useState(null);
  const [previewError, setPreviewError] = useState(null);
  const [userIdentifier, setUserIdentifier] = useState(null);
  const [isIdentifierLoading, setIsIdentifierLoading] = useState(true);

  const { createWavBlob } = audioUtils;

  useEffect(() => {
    const fetchIdentifier = async () => {
      setIsIdentifierLoading(true);
      const id = await usageService.getUserIdentifier();
      setUserIdentifier(id);
      setIsIdentifierLoading(false);
    };
    fetchIdentifier();
  }, []);

  const unlockApp = () => {
    if (userIdentifier) {
        usageService.unlockApp(userIdentifier);
        setShowPaywall(false);
    }
  };

  const parseBibleRef = (ref) => {
    const match = ref.trim().match(/^(.*\D)\s*(\d+):(\d+)$/);
    if (!match) return null;
    return { book: match[1].trim(), chapter: parseInt(match[2], 10), verse: parseInt(match[3], 10) };
  };

  const formatBibleRef = (parsed) => `${parsed.book} ${parsed.chapter}:${parsed.verse}`;

  const getNextVerseRef = useCallback(() => {
    const parsed = parseBibleRef(bibleReference);
    return parsed ? formatBibleRef({ ...parsed, verse: parsed.verse + 1 }) : '';
  }, [bibleReference]);

  useEffect(() => {
    return () => { if (generatedAudioUrl) URL.revokeObjectURL(generatedAudioUrl); };
  }, [generatedAudioUrl]);

  const handleStartNew = () => {
    setIsSequenceActive(false); setCharacterDescriptions(null); setGeneratedImage(null);
    setImageError(null); setPromptError(null); setPromptText(''); setBibleReference('');
    setGeneratedAudioUrl(null); setTextForNarration(''); setNarratedText(null);
  };

  const handleGeneratePrompt = useCallback(async () => {
    if (!bibleReference.trim()) return;
    setIsSequenceActive(false); setCharacterDescriptions(null); setGeneratedImage(null);
    setImageError(null); setPromptError(null); setPromptText(''); setGeneratedAudioUrl(null);
    setTextForNarration(''); setNarratedText(null);
    setIsPromptLoading(true);

    try {
      const { scenePrompt, characterDescriptions: newChars } = await geminiService.generateImagePrompt(bibleReference);
      setPromptText(scenePrompt); setCharacterDescriptions(newChars);
    } catch (err) {
      console.error(err);
      if (err.toString().includes('500') || err.toString().includes('Rpc failed')) {
        setPromptError('Ocorreu um erro de comunicação com o servidor. Por favor, tente novamente em alguns instantes.');
      } else {
        setPromptError(err.message || 'Ocorreu um erro ao gerar o prompt. Tente um versículo diferente.');
      }
    } finally {
      setIsPromptLoading(false);
    }
  }, [bibleReference]);

  const handleGenerateImage = useCallback(async () => {
    if (!promptText.trim() || isImageLoading || !userIdentifier) return;
    if (!usageService.isUnlocked(userIdentifier) && usageService.getUsageCount(userIdentifier) >= 3) {
      setShowPaywall(true); return;
    }
    setIsImageLoading(true); setImageError(null); setGeneratedImage(null);
    try {
      const imageBase64 = await geminiService.generateImage(promptText, aspectRatio);
      setGeneratedImage(`data:image/jpeg;base64,${imageBase64}`);
      setIsSequenceActive(true);
      usageService.incrementUsageCount(userIdentifier);
    } catch (err) {
      console.error(err);
      if (err.toString().includes('500') || err.toString().includes('Rpc failed')) {
        setImageError('Ocorreu um erro de comunicação com o servidor. Por favor, tente novamente em alguns instantes.');
      } else {
        setImageError(err.message || 'Ocorreu um erro ao gerar a imagem. Por favor, tente novamente.');
      }
    } finally {
      setIsImageLoading(false);
    }
  }, [promptText, isImageLoading, aspectRatio, userIdentifier]);

  const handleGenerateNextVerse = useCallback(async () => {
    const nextVerseRef = getNextVerseRef();
    if (!nextVerseRef || !characterDescriptions || !userIdentifier) return;
    if (!usageService.isUnlocked(userIdentifier) && usageService.getUsageCount(userIdentifier) >= 3) {
      setShowPaywall(true); return;
    }
    setIsImageLoading(true); setImageError(null); setPromptError(null);
    const lastValidRef = bibleReference;
    try {
      setBibleReference(nextVerseRef);
      const { scenePrompt, characterDescriptions: updatedChars } = await geminiService.generateImagePrompt(nextVerseRef, characterDescriptions);
      setPromptText(scenePrompt); setCharacterDescriptions(updatedChars);
      const imageBase64 = await geminiService.generateImage(scenePrompt, aspectRatio);
      setGeneratedImage(`data:image/jpeg;base64,${imageBase64}`);
      setIsSequenceActive(true);
      usageService.incrementUsageCount(userIdentifier);
    } catch (err) {
      if (err instanceof Error && err.message.includes('VERSE_NOT_FOUND')) {
        setImageError("Fim do capítulo. Inicie uma nova cena.");
        setIsSequenceActive(false); setBibleReference(lastValidRef);
      } else if (err.toString().includes('500') || err.toString().includes('Rpc failed')) {
        setImageError('Ocorreu um erro de comunicação com o servidor. Por favor, tente novamente em alguns instantes.');
        setBibleReference(lastValidRef);
      } else {
        setImageError(err.message || 'Falha ao gerar o próximo versículo.');
        setBibleReference(lastValidRef);
      }
    } finally {
      setIsImageLoading(false);
    }
  }, [characterDescriptions, aspectRatio, getNextVerseRef, bibleReference, userIdentifier]);

  const handleDownload = (base64Image, fileNameSuffix) => {
    if (!base64Image) return;
    const link = document.createElement('a');
    link.href = base64Image;
    const fileName = `${bibleReference.replace(/[: ]/g, '_').toLowerCase()}_${fileNameSuffix}.jpg`;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleFetchVerseText = useCallback(async () => {
    if (!bibleReference.trim() || isFetchingVerse) return;
    setIsFetchingVerse(true); setAudioError(null); setTextForNarration('');
    try {
        const verseText = await geminiService.getVerseText(bibleReference, language);
        setTextForNarration(verseText);
    } catch (err) {
        console.error(err);
        if (err.toString().includes('500') || err.toString().includes('Rpc failed')) {
            setAudioError('Ocorreu um erro de comunicação com o servidor. Por favor, tente novamente.');
        } else {
            setAudioError('Ocorreu um erro ao buscar o texto. Verifique a referência ou tente novamente.');
        }
    } finally {
        setIsFetchingVerse(false);
    }
  }, [bibleReference, language, isFetchingVerse]);

  const handleGenerateAudioClick = useCallback(async () => {
    if (!textForNarration.trim() || isAudioLoading) return;
    setIsAudioLoading(true); setAudioError(null);
    if (generatedAudioUrl) URL.revokeObjectURL(generatedAudioUrl);
    setGeneratedAudioUrl(null); setNarratedText(null);
    try {
        const audioBase64 = await geminiService.generateSpeech(textForNarration, voiceType === 'masculina' ? 'adulta' : 'infantil');
        const audioBlob = createWavBlob(audioBase64);
        const url = URL.createObjectURL(audioBlob);
        setGeneratedAudioUrl(url); setNarratedText(textForNarration);
    } catch (err) {
        console.error(err);
        if (err.toString().includes('500') || err.toString().includes('Rpc failed')) {
            setAudioError('Ocorreu um erro de comunicação com o servidor. Por favor, tente novamente.');
        } else {
            setAudioError('Ocorreu um erro ao gerar o áudio. Por favor, tente novamente.');
        }
    } finally {
        setIsAudioLoading(false);
    }
  }, [textForNarration, voiceType, isAudioLoading, generatedAudioUrl]);

  const handlePreviewVoice = useCallback(async (vType) => {
    if (previewLoading) return;
    setPreviewLoading(vType); setPreviewError(null);
    try {
        const audioBase64 = await geminiService.generateVoicePreview(vType === 'masculina' ? 'adulta' : 'infantil');
        const audioBlob = createWavBlob(audioBase64);
        const url = URL.createObjectURL(audioBlob);
        const audio = new Audio(url);
        audio.play();
        audio.onended = () => URL.revokeObjectURL(url);
    } catch (error) {
        console.error("Error playing voice preview:", error);
        setPreviewError("Não foi possível carregar a prévia da voz.");
    } finally {
        setPreviewLoading(null);
    }
  }, [previewLoading]);

  const isAnyLoading = isIdentifierLoading || isPromptLoading || isImageLoading || isAudioLoading || isFetchingVerse;
  const LANGUAGES = { 'pt-BR': 'Português', 'en-US': 'Inglês', 'es-ES': 'Espanhol', 'fr-FR': 'Francês', 'de-DE': 'Alemão' };

  return (
    <div className="flex flex-col items-center gap-8">
      {showPaywall && <PaywallPopup onUnlock={unlockApp} />}
      <div className="w-full max-w-2xl bg-slate-800/60 rounded-xl p-6 shadow-2xl shadow-cyan-500/10 border border-slate-700">
        <div className="flex items-end gap-4">
          <div className="flex-grow">
            <label htmlFor="bible-ref" className="block text-lg font-medium text-gray-300 mb-2">Capítulo e Versículo da Bíblia</label>
            <input id="bible-ref" type="text" value={bibleReference} onChange={(e) => setBibleReference(e.target.value)} placeholder="Ex: Gênesis 1:1"
              className="w-full bg-slate-900 border border-slate-600 rounded-lg px-4 py-3 text-gray-200 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition duration-300 disabled:bg-slate-800 disabled:cursor-not-allowed"
              disabled={isAnyLoading || isSequenceActive}
            />
          </div>
          {isSequenceActive && (
            <button onClick={handleStartNew} disabled={isAnyLoading} className="bg-red-600/80 text-white font-bold py-3 px-5 rounded-lg hover:bg-red-700 transition duration-300 disabled:opacity-50">
              Nova Cena
            </button>
          )}
        </div>
      </div>
      <div className="w-full max-w-2xl bg-slate-800/60 rounded-xl p-6 shadow-2xl shadow-cyan-500/10 border border-slate-700">
        <h2 className="text-xl font-semibold text-center text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500 mb-2">Passo 1: Crie o Prompt da Cena</h2>
        <div className="flex flex-col gap-4">
          <button onClick={handleGeneratePrompt} disabled={!bibleReference.trim() || isAnyLoading || isSequenceActive}
            className="bg-gradient-to-r from-slate-600 to-slate-700 text-white font-bold py-3 px-6 rounded-lg hover:from-slate-700 hover:to-slate-800 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-full">
            {isIdentifierLoading ? 'Verificando...' : isPromptLoading ? <Spinner /> : 'Gerar Prompt Automaticamente'}
          </button>
          <textarea value={promptText} onChange={(e) => setPromptText(e.target.value)} placeholder="Clique no botão acima para gerar um prompt, ou escreva sua própria descrição da cena aqui..."
            className="w-full bg-slate-900 border border-slate-600 rounded-lg px-4 py-3 text-gray-200 focus:ring-2 focus:ring-cyan-500 focus:outline-none transition duration-300 resize-none h-32"
            disabled={isAnyLoading}
          />
        </div>
      </div>
      {promptError && <div className="text-center p-4 bg-red-900/50 border border-red-700 rounded-lg text-red-300 w-full max-w-2xl"><p>{promptError}</p></div>}
      <div className="w-full max-w-2xl bg-slate-800/60 rounded-xl p-6 shadow-2xl shadow-cyan-500/10 border border-slate-700">
         <h2 className="text-xl font-semibold text-center text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500 mb-4">Passo 2: Gere a Imagem</h2>
        <div className="mb-4">
            <p className="block text-sm font-medium text-gray-400 mb-2 text-center">Formato da Imagem</p>
            <div className="flex items-center justify-center gap-4">
                {['9:16', '16:9'].map(ratio => (
                    <div key={ratio}>
                        <input type="radio" id={`aspect-${ratio.replace(':','-')}`} name="aspectRatio" value={ratio} checked={aspectRatio === ratio} onChange={() => setAspectRatio(ratio)} disabled={isAnyLoading} className="sr-only peer"/>
                        <label htmlFor={`aspect-${ratio.replace(':','-')}`} className="flex flex-col items-center text-sm gap-1 justify-center px-4 py-2 bg-slate-900/50 border border-slate-600 rounded-lg cursor-pointer peer-checked:border-cyan-500 peer-checked:ring-2 peer-checked:ring-cyan-500/50 peer-disabled:opacity-50 peer-disabled:cursor-not-allowed transition-all">
                            {ratio === '9:16' ? <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" className="w-5 h-5"><rect x="7" y="3" width="10" height="18" rx="1" stroke="currentColor" strokeWidth="2"/></svg> : <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" className="w-5 h-5"><rect x="3" y="7" width="18" height="10" rx="1" stroke="currentColor" strokeWidth="2"/></svg>}
                            <span>{ratio === '9:16' ? 'Vertical' : 'Horizontal'}</span>
                        </label>
                    </div>
                ))}
            </div>
        </div>
        <button onClick={handleGenerateImage} disabled={!promptText.trim() || isAnyLoading || isSequenceActive}
          className="bg-gradient-to-r from-cyan-500 to-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:from-cyan-600 hover:to-blue-700 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-full">
          {isIdentifierLoading ? 'Verificando...' : isImageLoading ? <Spinner /> : 'Gerar Imagem'}
        </button>
      </div>
      {isImageLoading && !generatedImage && <div className="text-center p-4 bg-slate-800 rounded-lg"><p className="text-cyan-400">Gerando a imagem... Isso pode levar alguns instantes.</p></div>}
      {imageError && <div className="text-center p-4 bg-red-900/50 border border-red-700 rounded-lg text-red-300 w-full max-w-2xl"><p>{imageError}</p></div>}
      {generatedImage && (
        <div className={`w-full flex flex-col items-center gap-4 ${aspectRatio === '9:16' ? 'max-w-md' : 'max-w-2xl'}`}>
           <div className="w-full relative group">
              <img src={generatedImage} alt={`Cena de ${bibleReference}`} className="rounded-xl shadow-lg shadow-black/50 border-2 border-slate-700 w-full"/>
              <div className="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300 rounded-xl">
                 <button onClick={() => handleDownload(generatedImage, 'scene')} className="bg-white/20 backdrop-blur-sm text-white font-bold py-3 px-5 rounded-lg hover:bg-white/30 transition duration-300 flex items-center gap-2">
                    <DownloadIcon /> Baixar Imagem
                  </button>
              </div>
           </div>
           {isSequenceActive && (
             <div className="w-full mt-2">
               <button onClick={handleGenerateNextVerse} disabled={isAnyLoading}
                 className="w-full bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 px-6 rounded-lg hover:from-green-600 hover:to-emerald-700 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center">
                 {isIdentifierLoading ? 'Verificando...' : isImageLoading ? <Spinner /> : `Gerar Próximo Versículo (${getNextVerseRef()})`}
               </button>
             </div>
           )}
        </div>
      )}
      <div className="w-full max-w-2xl"><AdSenseUnit /></div>
      <hr className="w-full max-w-2xl border-slate-700 my-4" />
      <div className="w-full max-w-2xl bg-slate-800/60 rounded-xl p-6 shadow-2xl shadow-blue-500/10 border border-slate-700">
        <div className="flex flex-col gap-4">
            <h2 className="text-xl font-semibold text-center text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-indigo-500 mb-2">Gerador de Narração</h2>
            <div className="flex flex-col gap-2">
                <label htmlFor="narration-text" className="block text-sm font-medium text-gray-400">Texto para Narrar</label>
                <textarea id="narration-text" value={textForNarration} onChange={(e) => setTextForNarration(e.target.value)} placeholder="Clique em 'Buscar Texto' para preencher automaticamente, ou cole o texto aqui."
                    className="w-full bg-slate-900 border border-slate-600 rounded-lg px-4 py-3 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none transition duration-300 resize-none h-28"
                    disabled={isAnyLoading}/>
                <button onClick={handleFetchVerseText} disabled={!bibleReference.trim() || isAnyLoading}
                    className="bg-gradient-to-r from-slate-600 to-slate-700 text-white font-bold py-2 px-4 rounded-lg hover:from-slate-700 hover:to-slate-800 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-full">
                    {isFetchingVerse ? <Spinner /> : 'Buscar Texto do Versículo'}
                </button>
            </div>
            <p className="text-center text-gray-400 text-sm my-2">Escolha o idioma e a voz para a narração.</p>
             <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                 <div>
                    <label htmlFor="language-select" className="block text-sm font-medium text-gray-400 mb-1">Idioma</label>
                    <select id="language-select" value={language} onChange={(e) => setLanguage(e.target.value)} disabled={isAnyLoading}
                        className="w-full bg-slate-900 border border-slate-600 rounded-lg px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none transition duration-300">
                        {Object.entries(LANGUAGES).map(([code, name]) => (<option key={code} value={code}>{name}</option>))}
                    </select>
                </div>
                <div className="flex flex-col justify-end">
                     <p className="block text-sm font-medium text-gray-400 mb-1">Tipo de Voz</p>
                    <div className="flex items-center justify-around gap-4 bg-slate-900 border border-slate-600 rounded-lg p-2 h-full">
                        {['masculina', 'feminina'].map((type) => (
                            <div key={type} className="flex items-center">
                                <label className="flex items-center gap-2 cursor-pointer text-base">
                                    <input type="radio" name="voiceType" value={type} checked={voiceType === type} onChange={(e) => setVoiceType(e.target.value)}
                                        className="form-radio h-4 w-4 text-cyan-500 bg-slate-700 border-slate-600 focus:ring-cyan-500" disabled={isAnyLoading}/>
                                    <span className="capitalize">{type}</span>
                                </label>
                                <button onClick={() => handlePreviewVoice(type)} disabled={isAnyLoading || !!previewLoading} className="ml-2 p-1 rounded-full hover:bg-slate-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" aria-label={`Ouvir prévia da voz ${type}`}>
                                    {previewLoading === type ? <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div> : <PlayIcon className="w-4 h-4 text-cyan-400" />}
                                </button>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            {previewError && <p className="text-red-400 text-xs text-center mt-2">{previewError}</p>}
            <button onClick={handleGenerateAudioClick} disabled={!textForNarration.trim() || isAnyLoading}
                className="bg-gradient-to-r from-blue-500 to-indigo-600 text-white font-bold py-3 px-6 rounded-lg hover:from-blue-600 hover:to-indigo-700 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-full mt-4">
                {isAudioLoading ? <Spinner /> : 'Gerar Áudio'}
            </button>
        </div>
      </div>
      {isAudioLoading && (
        <div className="text-center p-4 bg-slate-800 rounded-lg w-full max-w-2xl">
          <p className="text-blue-400">
            {voiceType === 'masculina' 
              ? 'Gerando narração... a voz masculina pode levar um pouco mais de tempo.' 
              : 'Gerando narração...'}
          </p>
        </div>
      )}
      {audioError && <div className="text-center p-4 bg-red-900/50 border border-red-700 rounded-lg text-red-300 w-full max-w-2xl"><p>{audioError}</p></div>}
      {generatedAudioUrl && (
        <div className="w-full max-w-md mt-4 flex flex-col gap-4">
           {narratedText && (
                <div className="bg-slate-900/70 p-4 rounded-lg border border-slate-700">
                    <p className="text-gray-300 italic text-center">"{narratedText}"</p>
                </div>
            )}
           <audio controls src={generatedAudioUrl} className="w-full">
              Seu navegador não suporta o elemento de áudio.
           </audio>
        </div>
      )}
    </div>
  );
};


const LandingPage = ({ onLogin }) => {
  const [isAudioLoading, setIsAudioLoading] = useState(false);
  const [audioError, setAudioError] = useState(null);
  const [generatedAudioUrl, setGeneratedAudioUrl] = useState(null);

  const { createWavBlob } = audioUtils;

  useEffect(() => {
    return () => {
        if (generatedAudioUrl) {
            URL.revokeObjectURL(generatedAudioUrl);
        }
    };
  }, [generatedAudioUrl]);

  const handleGenerateAudio = async () => {
    if (isAudioLoading) return;
    setIsAudioLoading(true);
    setAudioError(null);
    if (generatedAudioUrl) {
        URL.revokeObjectURL(generatedAudioUrl);
        setGeneratedAudioUrl(null);
    }

    try {
        const audioBase64 = await geminiService.generatePresentationAudio();
        const audioBlob = createWavBlob(audioBase64);
        const url = URL.createObjectURL(audioBlob);
        setGeneratedAudioUrl(url);
    } catch (err) {
        setAudioError('Falha ao gerar o áudio da apresentação. Tente novamente.');
        console.error(err);
    } finally {
        setIsAudioLoading(false);
    }
  };


  return (
    <div className="min-h-screen bg-slate-900 text-gray-100 font-sans overflow-x-hidden">
      <div className="relative isolate px-6 pt-14 lg:px-8">
        <div className="absolute inset-x-0 -top-40 -z-10 transform-gpu overflow-hidden blur-3xl sm:-top-80" aria-hidden="true">
          <div 
            className="relative left-[calc(50%-11rem)] aspect-[1155/678] w-[36.125rem] -translate-x-1/2 rotate-[30deg] bg-gradient-to-tr from-[#80ffdb] to-[#2563eb] opacity-30 sm:left-[calc(50%-30rem)] sm:w-[72.1875rem]" 
            style={{ clipPath: 'polygon(74.1% 44.1%, 100% 61.6%, 97.5% 26.9%, 85.5% 0.1%, 80.7% 2%, 72.5% 32.5%, 60.2% 62.4%, 52.4% 68.1%, 47.5% 58.3%, 45.2% 34.5%, 27.5% 76.7%, 0.1% 64.9%, 17.9% 100%, 27.6% 76.8%, 76.1% 97.7%, 74.1% 44.1%)' }}
          />
        </div>

        {/* Hero Section */}
        <div className="mx-auto max-w-4xl py-24 sm:py-32">
          <div className="text-center">
             <h1 className="text-4xl font-bold tracking-tight text-white sm:text-6xl text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
                Dê Vida à Bíblia
             </h1>
             <p className="mt-6 text-lg leading-8 text-gray-300">
                Transforme qualquer versículo em arte cinematográfica no estilo Pixar e narrações cativantes com o poder da IA.
             </p>
             <div className="mt-10 flex items-center justify-center gap-x-6">
                <button
                  onClick={onLogin}
                  className="rounded-md bg-cyan-600 px-5 py-3 text-base font-semibold text-white shadow-sm hover:bg-cyan-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-cyan-600 transition-transform duration-300 hover:scale-105"
                >
                  Teste Agora
                </button>
                <button 
                  onClick={handleGenerateAudio}
                  disabled={isAudioLoading}
                  className="text-base font-semibold leading-6 text-gray-300 flex items-center gap-2 group disabled:opacity-50"
                >
                   {isAudioLoading ? <Spinner /> : <SpeakerIcon className="w-6 h-6 group-hover:text-cyan-400 transition-colors" />} 
                   <span className="group-hover:text-white transition-colors">Ouvir Apresentação</span>
                </button>
             </div>
             {audioError && <p className="mt-4 text-red-400">{audioError}</p>}
             {generatedAudioUrl && (
                <div className="mt-8 flex justify-center">
                    <audio controls autoPlay src={generatedAudioUrl} className="w-full max-w-sm">
                        Seu navegador não suporta o elemento de áudio.
                    </audio>
                </div>
             )}
          </div>
        </div>

        {/* Features Section */}
        <div className="mx-auto max-w-7xl px-6 lg:px-8 py-16 sm:py-24">
            <div className="mx-auto max-w-2xl lg:text-center">
                <p className="text-3xl font-bold tracking-tight text-white sm:text-4xl">Uma Ferramenta Criativa para Sua Fé</p>
                <p className="mt-6 text-lg leading-8 text-gray-400">
                    Explore as escrituras como nunca antes, com ferramentas que inspiram e educam.
                </p>
            </div>
            <div className="mx-auto mt-16 max-w-2xl sm:mt-20 lg:mt-24 lg:max-w-4xl">
                <dl className="grid max-w-xl grid-cols-1 gap-x-8 gap-y-10 lg:max-w-none lg:grid-cols-3 lg:gap-y-16">
                    <div className="relative pl-16">
                        <dt className="text-base font-semibold leading-7 text-white">
                            <div className="absolute left-0 top-0 flex h-10 w-10 items-center justify-center rounded-lg bg-cyan-600">
                                <SparklesIcon className="h-6 w-6 text-white" />
                            </div>
                            Visualização Fiel
                        </dt>
                        <dd className="mt-2 text-base leading-7 text-gray-400">Crie imagens com precisão histórica e teológica, trazendo os relatos bíblicos para mais perto da realidade.</dd>
                    </div>
                    <div className="relative pl-16">
                        <dt className="text-base font-semibold leading-7 text-white">
                            <div className="absolute left-0 top-0 flex h-10 w-10 items-center justify-center rounded-lg bg-cyan-600">
                                <UsersIcon className="h-6 w-6 text-white" />
                            </div>
                            Continuidade de Personagens
                        </dt>
                        <dd className="mt-2 text-base leading-7 text-gray-400">Mantenha a aparência dos personagens consistente através de múltiplos versículos para criar histórias sequenciais.</dd>
                    </div>
                    <div className="relative pl-16">
                        <dt className="text-base font-semibold leading-7 text-white">
                            <div className="absolute left-0 top-0 flex h-10 w-10 items-center justify-center rounded-lg bg-cyan-600">
                                <MicIcon className="h-6 w-6 text-white" />
                            </div>
                            Narrações com IA
                        </dt>
                        <dd className="mt-2 text-base leading-7 text-gray-400">Gere áudios do texto bíblico em múltiplos idiomas e vozes, perfeito para estudos e apresentações.</dd>
                    </div>
                </dl>
            </div>
        </div>
        
        <div className="mx-auto max-w-7xl px-6 lg:px-8">
            <AdSenseUnit />
        </div>

        <div className="absolute inset-x-0 top-[calc(100%-13rem)] -z-10 transform-gpu overflow-hidden blur-3xl sm:top-[calc(100%-30rem)]" aria-hidden="true">
          <div 
            className="relative left-[calc(50%+3rem)] aspect-[1155/678] w-[36.125rem] -translate-x-1/2 bg-gradient-to-tr from-[#2563eb] to-[#80ffdb] opacity-30 sm:left-[calc(50%+36rem)] sm:w-[72.1875rem]" 
            style={{ clipPath: 'polygon(74.1% 44.1%, 100% 61.6%, 97.5% 26.9%, 85.5% 0.1%, 80.7% 2%, 72.5% 32.5%, 60.2% 62.4%, 52.4% 68.1%, 47.5% 58.3%, 45.2% 34.5%, 27.5% 76.7%, 0.1% 64.9%, 17.9% 100%, 27.6% 76.8%, 76.1% 97.7%, 74.1% 44.1%)' }}
          />
        </div>
      </div>
      <footer className="text-center py-6 text-gray-500 text-sm">
        <p>Criado com a API Gemini</p>
      </footer>
    </div>
  );
};


const App = () => {
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  const handleLogin = () => setIsLoggedIn(true);
  const handleLogout = () => setIsLoggedIn(false);

  if (!isLoggedIn) {
    return <LandingPage onLogin={handleLogin} />;
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 to-gray-800 text-gray-100 font-sans">
      <Header onLogout={handleLogout} />
      <main className="container mx-auto px-4 py-8">
        <ImageGenerator />
      </main>
      <footer className="text-center py-4 text-gray-500 text-sm">
        <p>Criado com a API Gemini</p>
      </footer>
    </div>
  );
};


const rootElement = document.getElementById('root');
if (rootElement) {
    const root = ReactDOM.createRoot(rootElement);
    root.render(
        <StrictMode>
            <App />
        </StrictMode>
    );
} else {
    throw new Error("Could not find root element to mount to");
}

    </script>
  </body>
</html>